package engine

import (
	"container/list"
)

type Tree struct {
	unmet map[string]interface{}
	list  *list.List
}

///////////////////////////////////////////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////////////////////////////////////////
func (t *Tree) GetIndex(cont interface{}) int {
	nIndex := 0
	for e := t.list.Front(); e != nil; e = e.Next() {
		if e.Value == cont {
			return nIndex
		}
		nIndex++
	}

	return -1
}

///////////////////////////////////////////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////////////////////////////////////////
func (t *Tree) GetContainerByName(name string) interface{} {
	for e := t.list.Front(); e != nil; e = e.Next() {
		cont := e.Value.(Container)
		if cont.name == name {
			return cont
		}
	}

	return nil
}

///////////////////////////////////////////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////////////////////////////////////////
func (t *Tree) TreePushBack(cont Container) *list.Element {
	elm := t.list.PushBack(cont)
	t.RemoveUnmetRequirement(cont.name)
	return elm
}

///////////////////////////////////////////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////////////////////////////////////////
func (t *Tree) TreeInsertBefore(cont Container, elm *list.Element) *list.Element {
	newElm := t.list.InsertBefore(cont, elm)
	t.RemoveUnmetRequirement(cont.name)
	return newElm
}

///////////////////////////////////////////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////////////////////////////////////////
func (t *Tree) TreeInsertAfter(cont Container, elm *list.Element) *list.Element {
	newElm := t.list.InsertAfter(cont, elm)
	t.RemoveUnmetRequirement(cont.name)
	return newElm
}

///////////////////////////////////////////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////////////////////////////////////////
func (t *Tree) RemoveUnmetRequirement(name string) {
	if _, ok := t.unmet[name]; ok {
		delete(t.unmet, name)
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////////////////////////////////////////
func (t *Tree) AddUnmetRequirement(name string) {
	if _, ok := t.unmet[name]; !ok {
		t.unmet[name] = name
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////////////////////////////////////////
func (t *Tree) First() *list.Element {
	return t.list.Front()
}

///////////////////////////////////////////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////////////////////////////////////////
func (t *Tree) Last() *list.Element {
	return t.list.Back()
}

///////////////////////////////////////////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////////////////////////////////////////
func (t *Tree) Length() int {
	return t.list.Len()
}

///////////////////////////////////////////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////////////////////////////////////////
func NewTree() *Tree {
	tree := &Tree{list: list.New()}
	tree.unmet = make(map[string]interface{})
	return tree
}
